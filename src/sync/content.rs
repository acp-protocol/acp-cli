//! @acp:module "Bootstrap Content Generator"
//! @acp:summary "Generates bootstrap content for AI tool files"
//! @acp:domain cli
//! @acp:layer service

use super::tool::Tool;

/// Generate bootstrap content in Markdown format
pub fn generate_bootstrap_markdown(tool: Tool) -> String {
    let has_mcp = tool.supports_mcp();
    let mut content = String::new();

    // Core awareness
    content.push_str("# ACP Context\n\n");
    content.push_str(
        "This project uses **AI Context Protocol (ACP)** for structured AI assistance.\n\n",
    );

    // Critical constraint workflow - most important section
    content.push_str("## Before Modifying Files\n\n");
    content.push_str("**ALWAYS check constraints before editing any file:**\n\n");

    if has_mcp {
        content.push_str("```\n");
        content.push_str("acp_check_constraints({ path: \"path/to/file\" })\n");
        content.push_str("```\n\n");
    } else {
        content.push_str("```bash\n");
        content.push_str("acp check path/to/file\n");
        content.push_str("# OR query directly:\n");
        content.push_str("jq '.constraints.by_file[\"path/to/file\"]' .acp/acp.cache.json\n");
        content.push_str("```\n\n");
    }

    // Lock levels
    content.push_str("### Constraint Levels\n\n");
    content.push_str("| Level | Action Required |\n");
    content.push_str("|-------|----------------|\n");
    content.push_str("| `frozen` | **NEVER** modify - ask user for alternatives |\n");
    content.push_str("| `restricted` | Explain changes and get approval first |\n");
    content.push_str("| `approval-required` | Ask before any change |\n");
    content.push_str("| `tests-required` | Include tests with changes |\n");
    content.push_str("| `docs-required` | Update documentation |\n\n");

    // Data files
    content.push_str("## Data Files\n\n");
    content.push_str("| File | Contents |\n");
    content.push_str("|------|----------|\n");
    content.push_str("| `.acp/acp.cache.json` | Indexed codebase structure, symbols, domains |\n");
    content.push_str("| `.acp/acp.vars.json` | Token-efficient variable definitions |\n");
    content.push_str("| `.acp.config.json` | Project configuration |\n\n");

    // Getting more context
    content.push_str("## Getting More Context\n\n");

    if has_mcp {
        content.push_str("Use MCP tools for queries:\n\n");
        content.push_str("- `acp_get_architecture()` - Project overview\n");
        content.push_str("- `acp_get_file_context({ path })` - File metadata\n");
        content.push_str("- `acp_get_symbol_context({ name })` - Symbol details\n");
        content.push_str("- `acp_get_hotpaths()` - Critical code paths\n");
        content.push_str("- `acp_expand_variable({ name })` - Expand $VAR references\n");
    } else {
        content.push_str("Use CLI or jq for queries:\n\n");
        content.push_str("```bash\n");
        content.push_str("# Query symbol details\n");
        content.push_str("acp query symbol <name>\n\n");
        content.push_str("# Query file metadata\n");
        content.push_str("acp query file <path>\n\n");
        content.push_str("# List domains\n");
        content.push_str("jq '.domains | keys' .acp/acp.cache.json\n\n");
        content.push_str("# Find frozen files\n");
        content.push_str("jq '.constraints.by_lock_level.frozen // []' .acp/acp.cache.json\n");
        content.push_str("```\n");
    }

    content
}

/// Generate bootstrap content wrapped for JSON (Continue.dev)
pub fn generate_bootstrap_json(tool: Tool) -> String {
    let markdown = generate_bootstrap_markdown(tool);

    // Create JSON config structure
    let config = serde_json::json!({
        "_acp": {
            "version": "1.0.0",
            "tool": tool.name()
        },
        "systemMessage": format!("{}", markdown)
    });

    serde_json::to_string_pretty(&config).unwrap_or_default()
}

/// Generate bootstrap content wrapped for YAML (Aider)
pub fn generate_bootstrap_yaml(tool: Tool) -> String {
    let markdown = generate_bootstrap_markdown(tool);

    // Indent each line for YAML multiline string
    let indented = markdown
        .lines()
        .map(|line| format!("  {}", line))
        .collect::<Vec<_>>()
        .join("\n");

    format!(
        "# ACP Configuration for {}\n\
         # Generated by AI Context Protocol\n\n\
         system-prompt: |\n{}\n",
        tool.name(),
        indented
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_markdown_without_mcp() {
        let content = generate_bootstrap_markdown(Tool::Cursor);
        assert!(content.contains("# ACP Context"));
        assert!(content.contains("acp check path/to/file"));
        assert!(!content.contains("acp_check_constraints"));
    }

    #[test]
    fn test_generate_markdown_with_mcp() {
        let content = generate_bootstrap_markdown(Tool::ClaudeCode);
        assert!(content.contains("# ACP Context"));
        assert!(content.contains("acp_check_constraints"));
        assert!(content.contains("acp_get_architecture"));
    }

    #[test]
    fn test_generate_json() {
        let content = generate_bootstrap_json(Tool::Continue);
        assert!(content.contains("\"_acp\""));
        assert!(content.contains("\"systemMessage\""));
        // Verify it's valid JSON
        let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
        assert!(parsed.get("systemMessage").is_some());
    }

    #[test]
    fn test_generate_yaml() {
        let content = generate_bootstrap_yaml(Tool::Aider);
        assert!(content.contains("system-prompt: |"));
        assert!(content.contains("ACP Configuration for Aider"));
    }
}
