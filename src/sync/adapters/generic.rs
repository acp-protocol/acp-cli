//! Generic adapter (AGENTS.md)

use std::path::Path;

use crate::error::Result;
use crate::sync::adapter::{BootstrapContext, DetectionResult, ToolAdapter};
use crate::sync::content::generate_bootstrap_markdown;
use crate::sync::tool::{MergeStrategy, Tool};

/// Generic adapter - generates AGENTS.md (fallback for any AI tool)
pub struct GenericAdapter;

impl ToolAdapter for GenericAdapter {
    fn tool(&self) -> Tool {
        Tool::Generic
    }

    fn detect(&self, _project_root: &Path) -> DetectionResult {
        // Always "detected" - serves as universal fallback
        DetectionResult {
            tool: Tool::Generic,
            detected: true,
            reason: "Universal fallback".into(),
            existing_file: None,
        }
    }

    fn generate(&self, _context: &BootstrapContext) -> Result<String> {
        let mut content = String::from(
            "# AGENTS.md - AI Assistant Context\n\n\
             This document provides context for AI assistants working with this codebase.\n\
             Generated by [AI Context Protocol](https://acp-protocol.dev).\n\n\
             ---\n\n",
        );

        content.push_str(&generate_bootstrap_markdown(Tool::Generic));

        content.push_str("\n---\n\n## Raw Data Access\n\n");
        content.push_str("For programmatic access to codebase intelligence:\n\n");
        content.push_str("| File | Purpose |\n");
        content.push_str("|------|--------|\n");
        content.push_str("| `.acp/acp.cache.json` | Complete codebase index |\n");
        content.push_str("| `.acp/acp.vars.json` | Variable definitions |\n");
        content.push_str("| `.acp.config.json` | Configuration |\n");

        Ok(content)
    }

    fn merge_strategy(&self) -> MergeStrategy {
        MergeStrategy::Replace // Full regeneration for AGENTS.md
    }
}
